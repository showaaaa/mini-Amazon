// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: world_amazon.proto

#include "world_amazon.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR UtoAzConnect::UtoAzConnect(
    ::_pbi::ConstantInitialized)
  : worldid_(int64_t{0}){}
struct UtoAzConnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UtoAzConnectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UtoAzConnectDefaultTypeInternal() {}
  union {
    UtoAzConnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UtoAzConnectDefaultTypeInternal _UtoAzConnect_default_instance_;
PROTOBUF_CONSTEXPR AzConnected::AzConnected(
    ::_pbi::ConstantInitialized)
  : result_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , worldid_(int64_t{0}){}
struct AzConnectedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AzConnectedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AzConnectedDefaultTypeInternal() {}
  union {
    AzConnected _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AzConnectedDefaultTypeInternal _AzConnected_default_instance_;
PROTOBUF_CONSTEXPR AItem::AItem(
    ::_pbi::ConstantInitialized)
  : description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , count_(int64_t{0}){}
struct AItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AItemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AItemDefaultTypeInternal() {}
  union {
    AItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AItemDefaultTypeInternal _AItem_default_instance_;
PROTOBUF_CONSTEXPR ASendTruck::ASendTruck(
    ::_pbi::ConstantInitialized)
  : items_()
  , package_id_(int64_t{0})
  , warehouse_id_(int64_t{0})
  , user_id_(int64_t{0})
  , x_(int64_t{0})
  , y_(int64_t{0}){}
struct ASendTruckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ASendTruckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ASendTruckDefaultTypeInternal() {}
  union {
    ASendTruck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ASendTruckDefaultTypeInternal _ASendTruck_default_instance_;
PROTOBUF_CONSTEXPR UTruckAtWH::UTruckAtWH(
    ::_pbi::ConstantInitialized)
  : truck_id_(int64_t{0})
  , warehouse_id_(int64_t{0})
  , package_id_(int64_t{0}){}
struct UTruckAtWHDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UTruckAtWHDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UTruckAtWHDefaultTypeInternal() {}
  union {
    UTruckAtWH _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UTruckAtWHDefaultTypeInternal _UTruckAtWH_default_instance_;
PROTOBUF_CONSTEXPR ATruckLoaded::ATruckLoaded(
    ::_pbi::ConstantInitialized)
  : truck_id_(int64_t{0})
  , warehouse_id_(int64_t{0})
  , package_id_(int64_t{0}){}
struct ATruckLoadedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ATruckLoadedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ATruckLoadedDefaultTypeInternal() {}
  union {
    ATruckLoaded _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ATruckLoadedDefaultTypeInternal _ATruckLoaded_default_instance_;
PROTOBUF_CONSTEXPR UPackageDelivered::UPackageDelivered(
    ::_pbi::ConstantInitialized)
  : package_id_(int64_t{0}){}
struct UPackageDeliveredDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UPackageDeliveredDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UPackageDeliveredDefaultTypeInternal() {}
  union {
    UPackageDelivered _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UPackageDeliveredDefaultTypeInternal _UPackageDelivered_default_instance_;
PROTOBUF_CONSTEXPR UMessage::UMessage(
    ::_pbi::ConstantInitialized)
  : truckatwh_(nullptr)
  , packagedelivered_(nullptr){}
struct UMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UMessageDefaultTypeInternal() {}
  union {
    UMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UMessageDefaultTypeInternal _UMessage_default_instance_;
PROTOBUF_CONSTEXPR AMessage::AMessage(
    ::_pbi::ConstantInitialized)
  : sendtruck_(nullptr)
  , truckloaded_(nullptr){}
struct AMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AMessageDefaultTypeInternal() {}
  union {
    AMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AMessageDefaultTypeInternal _AMessage_default_instance_;
PROTOBUF_CONSTEXPR AProduct::AProduct(
    ::_pbi::ConstantInitialized)
  : description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , id_(int64_t{0})
  , count_(0){}
struct AProductDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AProductDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AProductDefaultTypeInternal() {}
  union {
    AProduct _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AProductDefaultTypeInternal _AProduct_default_instance_;
PROTOBUF_CONSTEXPR AInitWarehouse::AInitWarehouse(
    ::_pbi::ConstantInitialized)
  : id_(0)
  , x_(0)
  , y_(0){}
struct AInitWarehouseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AInitWarehouseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AInitWarehouseDefaultTypeInternal() {}
  union {
    AInitWarehouse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AInitWarehouseDefaultTypeInternal _AInitWarehouse_default_instance_;
PROTOBUF_CONSTEXPR AConnect::AConnect(
    ::_pbi::ConstantInitialized)
  : initwh_()
  , worldid_(int64_t{0})
  , isamazon_(false){}
struct AConnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AConnectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AConnectDefaultTypeInternal() {}
  union {
    AConnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AConnectDefaultTypeInternal _AConnect_default_instance_;
PROTOBUF_CONSTEXPR AConnected::AConnected(
    ::_pbi::ConstantInitialized)
  : result_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , worldid_(int64_t{0}){}
struct AConnectedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AConnectedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AConnectedDefaultTypeInternal() {}
  union {
    AConnected _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AConnectedDefaultTypeInternal _AConnected_default_instance_;
PROTOBUF_CONSTEXPR APack::APack(
    ::_pbi::ConstantInitialized)
  : things_()
  , shipid_(int64_t{0})
  , seqnum_(int64_t{0})
  , whnum_(0){}
struct APackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR APackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~APackDefaultTypeInternal() {}
  union {
    APack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 APackDefaultTypeInternal _APack_default_instance_;
PROTOBUF_CONSTEXPR APacked::APacked(
    ::_pbi::ConstantInitialized)
  : shipid_(int64_t{0})
  , seqnum_(int64_t{0}){}
struct APackedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR APackedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~APackedDefaultTypeInternal() {}
  union {
    APacked _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 APackedDefaultTypeInternal _APacked_default_instance_;
PROTOBUF_CONSTEXPR ALoaded::ALoaded(
    ::_pbi::ConstantInitialized)
  : shipid_(int64_t{0})
  , seqnum_(int64_t{0}){}
struct ALoadedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ALoadedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ALoadedDefaultTypeInternal() {}
  union {
    ALoaded _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ALoadedDefaultTypeInternal _ALoaded_default_instance_;
PROTOBUF_CONSTEXPR APutOnTruck::APutOnTruck(
    ::_pbi::ConstantInitialized)
  : whnum_(0)
  , truckid_(0)
  , shipid_(int64_t{0})
  , seqnum_(int64_t{0}){}
struct APutOnTruckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR APutOnTruckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~APutOnTruckDefaultTypeInternal() {}
  union {
    APutOnTruck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 APutOnTruckDefaultTypeInternal _APutOnTruck_default_instance_;
PROTOBUF_CONSTEXPR APurchaseMore::APurchaseMore(
    ::_pbi::ConstantInitialized)
  : things_()
  , seqnum_(int64_t{0})
  , whnum_(0){}
struct APurchaseMoreDefaultTypeInternal {
  PROTOBUF_CONSTEXPR APurchaseMoreDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~APurchaseMoreDefaultTypeInternal() {}
  union {
    APurchaseMore _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 APurchaseMoreDefaultTypeInternal _APurchaseMore_default_instance_;
PROTOBUF_CONSTEXPR AErr::AErr(
    ::_pbi::ConstantInitialized)
  : err_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , originseqnum_(int64_t{0})
  , seqnum_(int64_t{0}){}
struct AErrDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AErrDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AErrDefaultTypeInternal() {}
  union {
    AErr _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AErrDefaultTypeInternal _AErr_default_instance_;
PROTOBUF_CONSTEXPR AQuery::AQuery(
    ::_pbi::ConstantInitialized)
  : packageid_(int64_t{0})
  , seqnum_(int64_t{0}){}
struct AQueryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AQueryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AQueryDefaultTypeInternal() {}
  union {
    AQuery _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AQueryDefaultTypeInternal _AQuery_default_instance_;
PROTOBUF_CONSTEXPR APackage::APackage(
    ::_pbi::ConstantInitialized)
  : status_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , packageid_(int64_t{0})
  , seqnum_(int64_t{0}){}
struct APackageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR APackageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~APackageDefaultTypeInternal() {}
  union {
    APackage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 APackageDefaultTypeInternal _APackage_default_instance_;
PROTOBUF_CONSTEXPR ACommands::ACommands(
    ::_pbi::ConstantInitialized)
  : buy_()
  , topack_()
  , load_()
  , queries_()
  , acks_()
  , simspeed_(0u)
  , disconnect_(false){}
struct ACommandsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ACommandsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ACommandsDefaultTypeInternal() {}
  union {
    ACommands _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ACommandsDefaultTypeInternal _ACommands_default_instance_;
PROTOBUF_CONSTEXPR AResponses::AResponses(
    ::_pbi::ConstantInitialized)
  : arrived_()
  , ready_()
  , loaded_()
  , error_()
  , acks_()
  , packagestatus_()
  , finished_(false){}
struct AResponsesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AResponsesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AResponsesDefaultTypeInternal() {}
  union {
    AResponses _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AResponsesDefaultTypeInternal _AResponses_default_instance_;
static ::_pb::Metadata file_level_metadata_world_5famazon_2eproto[23];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_world_5famazon_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_world_5famazon_2eproto = nullptr;

const uint32_t TableStruct_world_5famazon_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::UtoAzConnect, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::UtoAzConnect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UtoAzConnect, worldid_),
  0,
  PROTOBUF_FIELD_OFFSET(::AzConnected, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AzConnected, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AzConnected, worldid_),
  PROTOBUF_FIELD_OFFSET(::AzConnected, result_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::AItem, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AItem, description_),
  PROTOBUF_FIELD_OFFSET(::AItem, count_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ASendTruck, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ASendTruck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ASendTruck, package_id_),
  PROTOBUF_FIELD_OFFSET(::ASendTruck, warehouse_id_),
  PROTOBUF_FIELD_OFFSET(::ASendTruck, user_id_),
  PROTOBUF_FIELD_OFFSET(::ASendTruck, x_),
  PROTOBUF_FIELD_OFFSET(::ASendTruck, y_),
  PROTOBUF_FIELD_OFFSET(::ASendTruck, items_),
  0,
  1,
  2,
  3,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::UTruckAtWH, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::UTruckAtWH, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UTruckAtWH, truck_id_),
  PROTOBUF_FIELD_OFFSET(::UTruckAtWH, warehouse_id_),
  PROTOBUF_FIELD_OFFSET(::UTruckAtWH, package_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::ATruckLoaded, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ATruckLoaded, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ATruckLoaded, truck_id_),
  PROTOBUF_FIELD_OFFSET(::ATruckLoaded, warehouse_id_),
  PROTOBUF_FIELD_OFFSET(::ATruckLoaded, package_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::UPackageDelivered, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::UPackageDelivered, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UPackageDelivered, package_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::UMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::UMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UMessage, truckatwh_),
  PROTOBUF_FIELD_OFFSET(::UMessage, packagedelivered_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::AMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AMessage, sendtruck_),
  PROTOBUF_FIELD_OFFSET(::AMessage, truckloaded_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::AProduct, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AProduct, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AProduct, id_),
  PROTOBUF_FIELD_OFFSET(::AProduct, description_),
  PROTOBUF_FIELD_OFFSET(::AProduct, count_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::AInitWarehouse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AInitWarehouse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AInitWarehouse, id_),
  PROTOBUF_FIELD_OFFSET(::AInitWarehouse, x_),
  PROTOBUF_FIELD_OFFSET(::AInitWarehouse, y_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::AConnect, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AConnect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AConnect, worldid_),
  PROTOBUF_FIELD_OFFSET(::AConnect, initwh_),
  PROTOBUF_FIELD_OFFSET(::AConnect, isamazon_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::AConnected, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AConnected, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AConnected, worldid_),
  PROTOBUF_FIELD_OFFSET(::AConnected, result_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::APack, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::APack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::APack, whnum_),
  PROTOBUF_FIELD_OFFSET(::APack, things_),
  PROTOBUF_FIELD_OFFSET(::APack, shipid_),
  PROTOBUF_FIELD_OFFSET(::APack, seqnum_),
  2,
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::APacked, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::APacked, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::APacked, shipid_),
  PROTOBUF_FIELD_OFFSET(::APacked, seqnum_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ALoaded, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ALoaded, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ALoaded, shipid_),
  PROTOBUF_FIELD_OFFSET(::ALoaded, seqnum_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::APutOnTruck, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::APutOnTruck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::APutOnTruck, whnum_),
  PROTOBUF_FIELD_OFFSET(::APutOnTruck, truckid_),
  PROTOBUF_FIELD_OFFSET(::APutOnTruck, shipid_),
  PROTOBUF_FIELD_OFFSET(::APutOnTruck, seqnum_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::APurchaseMore, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::APurchaseMore, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::APurchaseMore, whnum_),
  PROTOBUF_FIELD_OFFSET(::APurchaseMore, things_),
  PROTOBUF_FIELD_OFFSET(::APurchaseMore, seqnum_),
  1,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::AErr, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AErr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AErr, err_),
  PROTOBUF_FIELD_OFFSET(::AErr, originseqnum_),
  PROTOBUF_FIELD_OFFSET(::AErr, seqnum_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::AQuery, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AQuery, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AQuery, packageid_),
  PROTOBUF_FIELD_OFFSET(::AQuery, seqnum_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::APackage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::APackage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::APackage, packageid_),
  PROTOBUF_FIELD_OFFSET(::APackage, status_),
  PROTOBUF_FIELD_OFFSET(::APackage, seqnum_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::ACommands, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ACommands, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ACommands, buy_),
  PROTOBUF_FIELD_OFFSET(::ACommands, topack_),
  PROTOBUF_FIELD_OFFSET(::ACommands, load_),
  PROTOBUF_FIELD_OFFSET(::ACommands, queries_),
  PROTOBUF_FIELD_OFFSET(::ACommands, simspeed_),
  PROTOBUF_FIELD_OFFSET(::ACommands, disconnect_),
  PROTOBUF_FIELD_OFFSET(::ACommands, acks_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::AResponses, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::AResponses, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AResponses, arrived_),
  PROTOBUF_FIELD_OFFSET(::AResponses, ready_),
  PROTOBUF_FIELD_OFFSET(::AResponses, loaded_),
  PROTOBUF_FIELD_OFFSET(::AResponses, finished_),
  PROTOBUF_FIELD_OFFSET(::AResponses, error_),
  PROTOBUF_FIELD_OFFSET(::AResponses, acks_),
  PROTOBUF_FIELD_OFFSET(::AResponses, packagestatus_),
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::UtoAzConnect)},
  { 8, 16, -1, sizeof(::AzConnected)},
  { 18, 26, -1, sizeof(::AItem)},
  { 28, 40, -1, sizeof(::ASendTruck)},
  { 46, 55, -1, sizeof(::UTruckAtWH)},
  { 58, 67, -1, sizeof(::ATruckLoaded)},
  { 70, 77, -1, sizeof(::UPackageDelivered)},
  { 78, 86, -1, sizeof(::UMessage)},
  { 88, 96, -1, sizeof(::AMessage)},
  { 98, 107, -1, sizeof(::AProduct)},
  { 110, 119, -1, sizeof(::AInitWarehouse)},
  { 122, 131, -1, sizeof(::AConnect)},
  { 134, 142, -1, sizeof(::AConnected)},
  { 144, 154, -1, sizeof(::APack)},
  { 158, 166, -1, sizeof(::APacked)},
  { 168, 176, -1, sizeof(::ALoaded)},
  { 178, 188, -1, sizeof(::APutOnTruck)},
  { 192, 201, -1, sizeof(::APurchaseMore)},
  { 204, 213, -1, sizeof(::AErr)},
  { 216, 224, -1, sizeof(::AQuery)},
  { 226, 235, -1, sizeof(::APackage)},
  { 238, 251, -1, sizeof(::ACommands)},
  { 258, 271, -1, sizeof(::AResponses)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_UtoAzConnect_default_instance_._instance,
  &::_AzConnected_default_instance_._instance,
  &::_AItem_default_instance_._instance,
  &::_ASendTruck_default_instance_._instance,
  &::_UTruckAtWH_default_instance_._instance,
  &::_ATruckLoaded_default_instance_._instance,
  &::_UPackageDelivered_default_instance_._instance,
  &::_UMessage_default_instance_._instance,
  &::_AMessage_default_instance_._instance,
  &::_AProduct_default_instance_._instance,
  &::_AInitWarehouse_default_instance_._instance,
  &::_AConnect_default_instance_._instance,
  &::_AConnected_default_instance_._instance,
  &::_APack_default_instance_._instance,
  &::_APacked_default_instance_._instance,
  &::_ALoaded_default_instance_._instance,
  &::_APutOnTruck_default_instance_._instance,
  &::_APurchaseMore_default_instance_._instance,
  &::_AErr_default_instance_._instance,
  &::_AQuery_default_instance_._instance,
  &::_APackage_default_instance_._instance,
  &::_ACommands_default_instance_._instance,
  &::_AResponses_default_instance_._instance,
};

const char descriptor_table_protodef_world_5famazon_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\022world_amazon.proto\"\037\n\014UtoAzConnect\022\017\n\007"
  "worldid\030\001 \002(\003\".\n\013AzConnected\022\017\n\007worldid\030"
  "\001 \002(\003\022\016\n\006result\030\002 \002(\t\"+\n\005AItem\022\023\n\013descri"
  "ption\030\001 \002(\t\022\r\n\005count\030\002 \002(\003\"t\n\nASendTruck"
  "\022\022\n\npackage_id\030\001 \002(\003\022\024\n\014warehouse_id\030\002 \002"
  "(\003\022\017\n\007user_id\030\003 \001(\003\022\t\n\001x\030\004 \002(\003\022\t\n\001y\030\005 \002("
  "\003\022\025\n\005items\030\006 \003(\0132\006.AItem\"H\n\nUTruckAtWH\022\020"
  "\n\010truck_id\030\001 \002(\003\022\024\n\014warehouse_id\030\002 \002(\003\022\022"
  "\n\npackage_id\030\003 \002(\003\"J\n\014ATruckLoaded\022\020\n\010tr"
  "uck_id\030\001 \002(\003\022\024\n\014warehouse_id\030\002 \002(\003\022\022\n\npa"
  "ckage_id\030\003 \002(\003\"\'\n\021UPackageDelivered\022\022\n\np"
  "ackage_id\030\003 \002(\003\"X\n\010UMessage\022\036\n\ttruckAtWH"
  "\030\001 \001(\0132\013.UTruckAtWH\022,\n\020packageDelivered\030"
  "\002 \001(\0132\022.UPackageDelivered\"N\n\010AMessage\022\036\n"
  "\tsendTruck\030\001 \001(\0132\013.ASendTruck\022\"\n\013truckLo"
  "aded\030\002 \001(\0132\r.ATruckLoaded\":\n\010AProduct\022\n\n"
  "\002id\030\001 \002(\003\022\023\n\013description\030\002 \002(\t\022\r\n\005count\030"
  "\003 \002(\005\"2\n\016AInitWarehouse\022\n\n\002id\030\001 \002(\005\022\t\n\001x"
  "\030\002 \002(\005\022\t\n\001y\030\003 \002(\005\"N\n\010AConnect\022\017\n\007worldid"
  "\030\001 \001(\003\022\037\n\006initwh\030\002 \003(\0132\017.AInitWarehouse\022"
  "\020\n\010isAmazon\030\003 \002(\010\"-\n\nAConnected\022\017\n\007world"
  "id\030\001 \002(\003\022\016\n\006result\030\002 \002(\t\"Q\n\005APack\022\r\n\005whn"
  "um\030\001 \002(\005\022\031\n\006things\030\002 \003(\0132\t.AProduct\022\016\n\006s"
  "hipid\030\003 \002(\003\022\016\n\006seqnum\030\004 \002(\003\")\n\007APacked\022\016"
  "\n\006shipid\030\001 \002(\003\022\016\n\006seqnum\030\002 \002(\003\")\n\007ALoade"
  "d\022\016\n\006shipid\030\001 \002(\003\022\016\n\006seqnum\030\002 \002(\003\"M\n\013APu"
  "tOnTruck\022\r\n\005whnum\030\001 \002(\005\022\017\n\007truckid\030\002 \002(\005"
  "\022\016\n\006shipid\030\003 \002(\003\022\016\n\006seqnum\030\004 \002(\003\"I\n\rAPur"
  "chaseMore\022\r\n\005whnum\030\001 \002(\005\022\031\n\006things\030\002 \003(\013"
  "2\t.AProduct\022\016\n\006seqnum\030\003 \002(\003\"9\n\004AErr\022\013\n\003e"
  "rr\030\001 \002(\t\022\024\n\014originseqnum\030\002 \002(\003\022\016\n\006seqnum"
  "\030\003 \002(\003\"+\n\006AQuery\022\021\n\tpackageid\030\001 \002(\003\022\016\n\006s"
  "eqnum\030\002 \002(\003\"=\n\010APackage\022\021\n\tpackageid\030\001 \002"
  "(\003\022\016\n\006status\030\002 \002(\t\022\016\n\006seqnum\030\003 \002(\003\"\252\001\n\tA"
  "Commands\022\033\n\003buy\030\001 \003(\0132\016.APurchaseMore\022\026\n"
  "\006topack\030\002 \003(\0132\006.APack\022\032\n\004load\030\003 \003(\0132\014.AP"
  "utOnTruck\022\030\n\007queries\030\004 \003(\0132\007.AQuery\022\020\n\010s"
  "imspeed\030\005 \001(\r\022\022\n\ndisconnect\030\006 \001(\010\022\014\n\004ack"
  "s\030\007 \003(\003\"\270\001\n\nAResponses\022\037\n\007arrived\030\001 \003(\0132"
  "\016.APurchaseMore\022\027\n\005ready\030\002 \003(\0132\010.APacked"
  "\022\030\n\006loaded\030\003 \003(\0132\010.ALoaded\022\020\n\010finished\030\004"
  " \001(\010\022\024\n\005error\030\005 \003(\0132\005.AErr\022\014\n\004acks\030\006 \003(\003"
  "\022 \n\rpackagestatus\030\007 \003(\0132\t.APackage"
  ;
static ::_pbi::once_flag descriptor_table_world_5famazon_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_world_5famazon_2eproto = {
    false, false, 1714, descriptor_table_protodef_world_5famazon_2eproto,
    "world_amazon.proto",
    &descriptor_table_world_5famazon_2eproto_once, nullptr, 0, 23,
    schemas, file_default_instances, TableStruct_world_5famazon_2eproto::offsets,
    file_level_metadata_world_5famazon_2eproto, file_level_enum_descriptors_world_5famazon_2eproto,
    file_level_service_descriptors_world_5famazon_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_world_5famazon_2eproto_getter() {
  return &descriptor_table_world_5famazon_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_world_5famazon_2eproto(&descriptor_table_world_5famazon_2eproto);

// ===================================================================

class UtoAzConnect::_Internal {
 public:
  using HasBits = decltype(std::declval<UtoAzConnect>()._has_bits_);
  static void set_has_worldid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

UtoAzConnect::UtoAzConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:UtoAzConnect)
}
UtoAzConnect::UtoAzConnect(const UtoAzConnect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  worldid_ = from.worldid_;
  // @@protoc_insertion_point(copy_constructor:UtoAzConnect)
}

inline void UtoAzConnect::SharedCtor() {
worldid_ = int64_t{0};
}

UtoAzConnect::~UtoAzConnect() {
  // @@protoc_insertion_point(destructor:UtoAzConnect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UtoAzConnect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UtoAzConnect::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UtoAzConnect::Clear() {
// @@protoc_insertion_point(message_clear_start:UtoAzConnect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  worldid_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UtoAzConnect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 worldid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_worldid(&has_bits);
          worldid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UtoAzConnect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UtoAzConnect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 worldid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_worldid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UtoAzConnect)
  return target;
}

size_t UtoAzConnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UtoAzConnect)
  size_t total_size = 0;

  // required int64 worldid = 1;
  if (_internal_has_worldid()) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_worldid());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UtoAzConnect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UtoAzConnect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UtoAzConnect::GetClassData() const { return &_class_data_; }

void UtoAzConnect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UtoAzConnect *>(to)->MergeFrom(
      static_cast<const UtoAzConnect &>(from));
}


void UtoAzConnect::MergeFrom(const UtoAzConnect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:UtoAzConnect)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_worldid()) {
    _internal_set_worldid(from._internal_worldid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UtoAzConnect::CopyFrom(const UtoAzConnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UtoAzConnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UtoAzConnect::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UtoAzConnect::InternalSwap(UtoAzConnect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(worldid_, other->worldid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UtoAzConnect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[0]);
}

// ===================================================================

class AzConnected::_Internal {
 public:
  using HasBits = decltype(std::declval<AzConnected>()._has_bits_);
  static void set_has_worldid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AzConnected::AzConnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:AzConnected)
}
AzConnected::AzConnected(const AzConnected& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  result_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    result_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_result()) {
    result_.Set(from._internal_result(), 
      GetArenaForAllocation());
  }
  worldid_ = from.worldid_;
  // @@protoc_insertion_point(copy_constructor:AzConnected)
}

inline void AzConnected::SharedCtor() {
result_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  result_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
worldid_ = int64_t{0};
}

AzConnected::~AzConnected() {
  // @@protoc_insertion_point(destructor:AzConnected)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AzConnected::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  result_.Destroy();
}

void AzConnected::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AzConnected::Clear() {
// @@protoc_insertion_point(message_clear_start:AzConnected)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    result_.ClearNonDefaultToEmpty();
  }
  worldid_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AzConnected::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 worldid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_worldid(&has_bits);
          worldid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_result();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "AzConnected.result");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AzConnected::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AzConnected)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 worldid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_worldid(), target);
  }

  // required string result = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_result().data(), static_cast<int>(this->_internal_result().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "AzConnected.result");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AzConnected)
  return target;
}

size_t AzConnected::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AzConnected)
  size_t total_size = 0;

  if (_internal_has_result()) {
    // required string result = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_result());
  }

  if (_internal_has_worldid()) {
    // required int64 worldid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_worldid());
  }

  return total_size;
}
size_t AzConnected::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AzConnected)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string result = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_result());

    // required int64 worldid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_worldid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AzConnected::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AzConnected::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AzConnected::GetClassData() const { return &_class_data_; }

void AzConnected::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AzConnected *>(to)->MergeFrom(
      static_cast<const AzConnected &>(from));
}


void AzConnected::MergeFrom(const AzConnected& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AzConnected)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_result(from._internal_result());
    }
    if (cached_has_bits & 0x00000002u) {
      worldid_ = from.worldid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AzConnected::CopyFrom(const AzConnected& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AzConnected)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AzConnected::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AzConnected::InternalSwap(AzConnected* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &result_, lhs_arena,
      &other->result_, rhs_arena
  );
  swap(worldid_, other->worldid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AzConnected::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[1]);
}

// ===================================================================

class AItem::_Internal {
 public:
  using HasBits = decltype(std::declval<AItem>()._has_bits_);
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AItem::AItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:AItem)
}
AItem::AItem(const AItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(from._internal_description(), 
      GetArenaForAllocation());
  }
  count_ = from.count_;
  // @@protoc_insertion_point(copy_constructor:AItem)
}

inline void AItem::SharedCtor() {
description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
count_ = int64_t{0};
}

AItem::~AItem() {
  // @@protoc_insertion_point(destructor:AItem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  description_.Destroy();
}

void AItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AItem::Clear() {
// @@protoc_insertion_point(message_clear_start:AItem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    description_.ClearNonDefaultToEmpty();
  }
  count_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AItem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string description = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "AItem.description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AItem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AItem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string description = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "AItem.description");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_description(), target);
  }

  // required int64 count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AItem)
  return target;
}

size_t AItem::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AItem)
  size_t total_size = 0;

  if (_internal_has_description()) {
    // required string description = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  if (_internal_has_count()) {
    // required int64 count = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_count());
  }

  return total_size;
}
size_t AItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AItem)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string description = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());

    // required int64 count = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AItem::GetClassData() const { return &_class_data_; }

void AItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AItem *>(to)->MergeFrom(
      static_cast<const AItem &>(from));
}


void AItem::MergeFrom(const AItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AItem)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AItem::CopyFrom(const AItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AItem::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AItem::InternalSwap(AItem* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  swap(count_, other->count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[2]);
}

// ===================================================================

class ASendTruck::_Internal {
 public:
  using HasBits = decltype(std::declval<ASendTruck>()._has_bits_);
  static void set_has_package_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_warehouse_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001b) ^ 0x0000001b) != 0;
  }
};

ASendTruck::ASendTruck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  items_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ASendTruck)
}
ASendTruck::ASendTruck(const ASendTruck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      items_(from.items_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&package_id_, &from.package_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&package_id_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:ASendTruck)
}

inline void ASendTruck::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&package_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&package_id_)) + sizeof(y_));
}

ASendTruck::~ASendTruck() {
  // @@protoc_insertion_point(destructor:ASendTruck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ASendTruck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ASendTruck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ASendTruck::Clear() {
// @@protoc_insertion_point(message_clear_start:ASendTruck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  items_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&package_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&package_id_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ASendTruck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 package_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_package_id(&has_bits);
          package_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 warehouse_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_warehouse_id(&has_bits);
          warehouse_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 user_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_user_id(&has_bits);
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .AItem items = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ASendTruck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ASendTruck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 package_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_package_id(), target);
  }

  // required int64 warehouse_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_warehouse_id(), target);
  }

  // optional int64 user_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_user_id(), target);
  }

  // required int64 x = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_x(), target);
  }

  // required int64 y = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_y(), target);
  }

  // repeated .AItem items = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ASendTruck)
  return target;
}

size_t ASendTruck::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ASendTruck)
  size_t total_size = 0;

  if (_internal_has_package_id()) {
    // required int64 package_id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_package_id());
  }

  if (_internal_has_warehouse_id()) {
    // required int64 warehouse_id = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_warehouse_id());
  }

  if (_internal_has_x()) {
    // required int64 x = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_x());
  }

  if (_internal_has_y()) {
    // required int64 y = 5;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_y());
  }

  return total_size;
}
size_t ASendTruck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ASendTruck)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001b) ^ 0x0000001b) == 0) {  // All required fields are present.
    // required int64 package_id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_package_id());

    // required int64 warehouse_id = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_warehouse_id());

    // required int64 x = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_x());

    // required int64 y = 5;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .AItem items = 6;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int64 user_id = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_user_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ASendTruck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ASendTruck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ASendTruck::GetClassData() const { return &_class_data_; }

void ASendTruck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ASendTruck *>(to)->MergeFrom(
      static_cast<const ASendTruck &>(from));
}


void ASendTruck::MergeFrom(const ASendTruck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ASendTruck)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  items_.MergeFrom(from.items_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      package_id_ = from.package_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      warehouse_id_ = from.warehouse_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000010u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ASendTruck::CopyFrom(const ASendTruck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ASendTruck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ASendTruck::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(items_))
    return false;
  return true;
}

void ASendTruck::InternalSwap(ASendTruck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  items_.InternalSwap(&other->items_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ASendTruck, y_)
      + sizeof(ASendTruck::y_)
      - PROTOBUF_FIELD_OFFSET(ASendTruck, package_id_)>(
          reinterpret_cast<char*>(&package_id_),
          reinterpret_cast<char*>(&other->package_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ASendTruck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[3]);
}

// ===================================================================

class UTruckAtWH::_Internal {
 public:
  using HasBits = decltype(std::declval<UTruckAtWH>()._has_bits_);
  static void set_has_truck_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_warehouse_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_package_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

UTruckAtWH::UTruckAtWH(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:UTruckAtWH)
}
UTruckAtWH::UTruckAtWH(const UTruckAtWH& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&truck_id_, &from.truck_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&package_id_) -
    reinterpret_cast<char*>(&truck_id_)) + sizeof(package_id_));
  // @@protoc_insertion_point(copy_constructor:UTruckAtWH)
}

inline void UTruckAtWH::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&truck_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&package_id_) -
    reinterpret_cast<char*>(&truck_id_)) + sizeof(package_id_));
}

UTruckAtWH::~UTruckAtWH() {
  // @@protoc_insertion_point(destructor:UTruckAtWH)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UTruckAtWH::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UTruckAtWH::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UTruckAtWH::Clear() {
// @@protoc_insertion_point(message_clear_start:UTruckAtWH)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&truck_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&package_id_) -
        reinterpret_cast<char*>(&truck_id_)) + sizeof(package_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UTruckAtWH::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 truck_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_truck_id(&has_bits);
          truck_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 warehouse_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_warehouse_id(&has_bits);
          warehouse_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 package_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_package_id(&has_bits);
          package_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UTruckAtWH::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UTruckAtWH)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 truck_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_truck_id(), target);
  }

  // required int64 warehouse_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_warehouse_id(), target);
  }

  // required int64 package_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_package_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UTruckAtWH)
  return target;
}

size_t UTruckAtWH::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:UTruckAtWH)
  size_t total_size = 0;

  if (_internal_has_truck_id()) {
    // required int64 truck_id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_truck_id());
  }

  if (_internal_has_warehouse_id()) {
    // required int64 warehouse_id = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_warehouse_id());
  }

  if (_internal_has_package_id()) {
    // required int64 package_id = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_package_id());
  }

  return total_size;
}
size_t UTruckAtWH::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UTruckAtWH)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int64 truck_id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_truck_id());

    // required int64 warehouse_id = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_warehouse_id());

    // required int64 package_id = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_package_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UTruckAtWH::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UTruckAtWH::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UTruckAtWH::GetClassData() const { return &_class_data_; }

void UTruckAtWH::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UTruckAtWH *>(to)->MergeFrom(
      static_cast<const UTruckAtWH &>(from));
}


void UTruckAtWH::MergeFrom(const UTruckAtWH& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:UTruckAtWH)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      truck_id_ = from.truck_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      warehouse_id_ = from.warehouse_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      package_id_ = from.package_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UTruckAtWH::CopyFrom(const UTruckAtWH& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UTruckAtWH)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UTruckAtWH::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UTruckAtWH::InternalSwap(UTruckAtWH* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UTruckAtWH, package_id_)
      + sizeof(UTruckAtWH::package_id_)
      - PROTOBUF_FIELD_OFFSET(UTruckAtWH, truck_id_)>(
          reinterpret_cast<char*>(&truck_id_),
          reinterpret_cast<char*>(&other->truck_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UTruckAtWH::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[4]);
}

// ===================================================================

class ATruckLoaded::_Internal {
 public:
  using HasBits = decltype(std::declval<ATruckLoaded>()._has_bits_);
  static void set_has_truck_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_warehouse_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_package_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

ATruckLoaded::ATruckLoaded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ATruckLoaded)
}
ATruckLoaded::ATruckLoaded(const ATruckLoaded& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&truck_id_, &from.truck_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&package_id_) -
    reinterpret_cast<char*>(&truck_id_)) + sizeof(package_id_));
  // @@protoc_insertion_point(copy_constructor:ATruckLoaded)
}

inline void ATruckLoaded::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&truck_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&package_id_) -
    reinterpret_cast<char*>(&truck_id_)) + sizeof(package_id_));
}

ATruckLoaded::~ATruckLoaded() {
  // @@protoc_insertion_point(destructor:ATruckLoaded)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ATruckLoaded::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ATruckLoaded::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ATruckLoaded::Clear() {
// @@protoc_insertion_point(message_clear_start:ATruckLoaded)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&truck_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&package_id_) -
        reinterpret_cast<char*>(&truck_id_)) + sizeof(package_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ATruckLoaded::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 truck_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_truck_id(&has_bits);
          truck_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 warehouse_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_warehouse_id(&has_bits);
          warehouse_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 package_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_package_id(&has_bits);
          package_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ATruckLoaded::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ATruckLoaded)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 truck_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_truck_id(), target);
  }

  // required int64 warehouse_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_warehouse_id(), target);
  }

  // required int64 package_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_package_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ATruckLoaded)
  return target;
}

size_t ATruckLoaded::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ATruckLoaded)
  size_t total_size = 0;

  if (_internal_has_truck_id()) {
    // required int64 truck_id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_truck_id());
  }

  if (_internal_has_warehouse_id()) {
    // required int64 warehouse_id = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_warehouse_id());
  }

  if (_internal_has_package_id()) {
    // required int64 package_id = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_package_id());
  }

  return total_size;
}
size_t ATruckLoaded::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ATruckLoaded)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int64 truck_id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_truck_id());

    // required int64 warehouse_id = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_warehouse_id());

    // required int64 package_id = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_package_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ATruckLoaded::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ATruckLoaded::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ATruckLoaded::GetClassData() const { return &_class_data_; }

void ATruckLoaded::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ATruckLoaded *>(to)->MergeFrom(
      static_cast<const ATruckLoaded &>(from));
}


void ATruckLoaded::MergeFrom(const ATruckLoaded& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ATruckLoaded)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      truck_id_ = from.truck_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      warehouse_id_ = from.warehouse_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      package_id_ = from.package_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ATruckLoaded::CopyFrom(const ATruckLoaded& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ATruckLoaded)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ATruckLoaded::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ATruckLoaded::InternalSwap(ATruckLoaded* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ATruckLoaded, package_id_)
      + sizeof(ATruckLoaded::package_id_)
      - PROTOBUF_FIELD_OFFSET(ATruckLoaded, truck_id_)>(
          reinterpret_cast<char*>(&truck_id_),
          reinterpret_cast<char*>(&other->truck_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ATruckLoaded::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[5]);
}

// ===================================================================

class UPackageDelivered::_Internal {
 public:
  using HasBits = decltype(std::declval<UPackageDelivered>()._has_bits_);
  static void set_has_package_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

UPackageDelivered::UPackageDelivered(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:UPackageDelivered)
}
UPackageDelivered::UPackageDelivered(const UPackageDelivered& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  package_id_ = from.package_id_;
  // @@protoc_insertion_point(copy_constructor:UPackageDelivered)
}

inline void UPackageDelivered::SharedCtor() {
package_id_ = int64_t{0};
}

UPackageDelivered::~UPackageDelivered() {
  // @@protoc_insertion_point(destructor:UPackageDelivered)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UPackageDelivered::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UPackageDelivered::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UPackageDelivered::Clear() {
// @@protoc_insertion_point(message_clear_start:UPackageDelivered)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  package_id_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UPackageDelivered::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 package_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_package_id(&has_bits);
          package_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UPackageDelivered::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UPackageDelivered)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 package_id = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_package_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UPackageDelivered)
  return target;
}

size_t UPackageDelivered::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UPackageDelivered)
  size_t total_size = 0;

  // required int64 package_id = 3;
  if (_internal_has_package_id()) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_package_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UPackageDelivered::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UPackageDelivered::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UPackageDelivered::GetClassData() const { return &_class_data_; }

void UPackageDelivered::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UPackageDelivered *>(to)->MergeFrom(
      static_cast<const UPackageDelivered &>(from));
}


void UPackageDelivered::MergeFrom(const UPackageDelivered& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:UPackageDelivered)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_package_id()) {
    _internal_set_package_id(from._internal_package_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UPackageDelivered::CopyFrom(const UPackageDelivered& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UPackageDelivered)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UPackageDelivered::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void UPackageDelivered::InternalSwap(UPackageDelivered* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(package_id_, other->package_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UPackageDelivered::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[6]);
}

// ===================================================================

class UMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<UMessage>()._has_bits_);
  static const ::UTruckAtWH& truckatwh(const UMessage* msg);
  static void set_has_truckatwh(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::UPackageDelivered& packagedelivered(const UMessage* msg);
  static void set_has_packagedelivered(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::UTruckAtWH&
UMessage::_Internal::truckatwh(const UMessage* msg) {
  return *msg->truckatwh_;
}
const ::UPackageDelivered&
UMessage::_Internal::packagedelivered(const UMessage* msg) {
  return *msg->packagedelivered_;
}
UMessage::UMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:UMessage)
}
UMessage::UMessage(const UMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_truckatwh()) {
    truckatwh_ = new ::UTruckAtWH(*from.truckatwh_);
  } else {
    truckatwh_ = nullptr;
  }
  if (from._internal_has_packagedelivered()) {
    packagedelivered_ = new ::UPackageDelivered(*from.packagedelivered_);
  } else {
    packagedelivered_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:UMessage)
}

inline void UMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&truckatwh_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&packagedelivered_) -
    reinterpret_cast<char*>(&truckatwh_)) + sizeof(packagedelivered_));
}

UMessage::~UMessage() {
  // @@protoc_insertion_point(destructor:UMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete truckatwh_;
  if (this != internal_default_instance()) delete packagedelivered_;
}

void UMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:UMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(truckatwh_ != nullptr);
      truckatwh_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(packagedelivered_ != nullptr);
      packagedelivered_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .UTruckAtWH truckAtWH = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_truckatwh(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .UPackageDelivered packageDelivered = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_packagedelivered(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .UTruckAtWH truckAtWH = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::truckatwh(this),
        _Internal::truckatwh(this).GetCachedSize(), target, stream);
  }

  // optional .UPackageDelivered packageDelivered = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::packagedelivered(this),
        _Internal::packagedelivered(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UMessage)
  return target;
}

size_t UMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .UTruckAtWH truckAtWH = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *truckatwh_);
    }

    // optional .UPackageDelivered packageDelivered = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *packagedelivered_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UMessage::GetClassData() const { return &_class_data_; }

void UMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UMessage *>(to)->MergeFrom(
      static_cast<const UMessage &>(from));
}


void UMessage::MergeFrom(const UMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:UMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_truckatwh()->::UTruckAtWH::MergeFrom(from._internal_truckatwh());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_packagedelivered()->::UPackageDelivered::MergeFrom(from._internal_packagedelivered());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UMessage::CopyFrom(const UMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UMessage::IsInitialized() const {
  if (_internal_has_truckatwh()) {
    if (!truckatwh_->IsInitialized()) return false;
  }
  if (_internal_has_packagedelivered()) {
    if (!packagedelivered_->IsInitialized()) return false;
  }
  return true;
}

void UMessage::InternalSwap(UMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UMessage, packagedelivered_)
      + sizeof(UMessage::packagedelivered_)
      - PROTOBUF_FIELD_OFFSET(UMessage, truckatwh_)>(
          reinterpret_cast<char*>(&truckatwh_),
          reinterpret_cast<char*>(&other->truckatwh_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[7]);
}

// ===================================================================

class AMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<AMessage>()._has_bits_);
  static const ::ASendTruck& sendtruck(const AMessage* msg);
  static void set_has_sendtruck(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ATruckLoaded& truckloaded(const AMessage* msg);
  static void set_has_truckloaded(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::ASendTruck&
AMessage::_Internal::sendtruck(const AMessage* msg) {
  return *msg->sendtruck_;
}
const ::ATruckLoaded&
AMessage::_Internal::truckloaded(const AMessage* msg) {
  return *msg->truckloaded_;
}
AMessage::AMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:AMessage)
}
AMessage::AMessage(const AMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sendtruck()) {
    sendtruck_ = new ::ASendTruck(*from.sendtruck_);
  } else {
    sendtruck_ = nullptr;
  }
  if (from._internal_has_truckloaded()) {
    truckloaded_ = new ::ATruckLoaded(*from.truckloaded_);
  } else {
    truckloaded_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:AMessage)
}

inline void AMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sendtruck_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&truckloaded_) -
    reinterpret_cast<char*>(&sendtruck_)) + sizeof(truckloaded_));
}

AMessage::~AMessage() {
  // @@protoc_insertion_point(destructor:AMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sendtruck_;
  if (this != internal_default_instance()) delete truckloaded_;
}

void AMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(sendtruck_ != nullptr);
      sendtruck_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(truckloaded_ != nullptr);
      truckloaded_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ASendTruck sendTruck = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sendtruck(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ATruckLoaded truckLoaded = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_truckloaded(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ASendTruck sendTruck = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::sendtruck(this),
        _Internal::sendtruck(this).GetCachedSize(), target, stream);
  }

  // optional .ATruckLoaded truckLoaded = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::truckloaded(this),
        _Internal::truckloaded(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AMessage)
  return target;
}

size_t AMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ASendTruck sendTruck = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sendtruck_);
    }

    // optional .ATruckLoaded truckLoaded = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *truckloaded_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AMessage::GetClassData() const { return &_class_data_; }

void AMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AMessage *>(to)->MergeFrom(
      static_cast<const AMessage &>(from));
}


void AMessage::MergeFrom(const AMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_sendtruck()->::ASendTruck::MergeFrom(from._internal_sendtruck());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_truckloaded()->::ATruckLoaded::MergeFrom(from._internal_truckloaded());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AMessage::CopyFrom(const AMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AMessage::IsInitialized() const {
  if (_internal_has_sendtruck()) {
    if (!sendtruck_->IsInitialized()) return false;
  }
  if (_internal_has_truckloaded()) {
    if (!truckloaded_->IsInitialized()) return false;
  }
  return true;
}

void AMessage::InternalSwap(AMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AMessage, truckloaded_)
      + sizeof(AMessage::truckloaded_)
      - PROTOBUF_FIELD_OFFSET(AMessage, sendtruck_)>(
          reinterpret_cast<char*>(&sendtruck_),
          reinterpret_cast<char*>(&other->sendtruck_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[8]);
}

// ===================================================================

class AProduct::_Internal {
 public:
  using HasBits = decltype(std::declval<AProduct>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

AProduct::AProduct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:AProduct)
}
AProduct::AProduct(const AProduct& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(from._internal_description(), 
      GetArenaForAllocation());
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&id_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:AProduct)
}

inline void AProduct::SharedCtor() {
description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&id_)) + sizeof(count_));
}

AProduct::~AProduct() {
  // @@protoc_insertion_point(destructor:AProduct)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AProduct::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  description_.Destroy();
}

void AProduct::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AProduct::Clear() {
// @@protoc_insertion_point(message_clear_start:AProduct)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    description_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&id_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AProduct::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "AProduct.description");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AProduct::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AProduct)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_id(), target);
  }

  // required string description = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "AProduct.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // required int32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AProduct)
  return target;
}

size_t AProduct::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AProduct)
  size_t total_size = 0;

  if (_internal_has_description()) {
    // required string description = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  if (_internal_has_id()) {
    // required int64 id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_id());
  }

  if (_internal_has_count()) {
    // required int32 count = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());
  }

  return total_size;
}
size_t AProduct::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AProduct)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string description = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());

    // required int64 id = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_id());

    // required int32 count = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AProduct::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AProduct::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AProduct::GetClassData() const { return &_class_data_; }

void AProduct::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AProduct *>(to)->MergeFrom(
      static_cast<const AProduct &>(from));
}


void AProduct::MergeFrom(const AProduct& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AProduct)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AProduct::CopyFrom(const AProduct& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AProduct)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AProduct::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AProduct::InternalSwap(AProduct* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AProduct, count_)
      + sizeof(AProduct::count_)
      - PROTOBUF_FIELD_OFFSET(AProduct, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AProduct::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[9]);
}

// ===================================================================

class AInitWarehouse::_Internal {
 public:
  using HasBits = decltype(std::declval<AInitWarehouse>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

AInitWarehouse::AInitWarehouse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:AInitWarehouse)
}
AInitWarehouse::AInitWarehouse(const AInitWarehouse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&id_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:AInitWarehouse)
}

inline void AInitWarehouse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&id_)) + sizeof(y_));
}

AInitWarehouse::~AInitWarehouse() {
  // @@protoc_insertion_point(destructor:AInitWarehouse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AInitWarehouse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AInitWarehouse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AInitWarehouse::Clear() {
// @@protoc_insertion_point(message_clear_start:AInitWarehouse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&id_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AInitWarehouse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AInitWarehouse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AInitWarehouse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required int32 x = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_x(), target);
  }

  // required int32 y = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AInitWarehouse)
  return target;
}

size_t AInitWarehouse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AInitWarehouse)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (_internal_has_x()) {
    // required int32 x = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  if (_internal_has_y()) {
    // required int32 y = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  return total_size;
}
size_t AInitWarehouse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AInitWarehouse)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());

    // required int32 x = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());

    // required int32 y = 3;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AInitWarehouse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AInitWarehouse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AInitWarehouse::GetClassData() const { return &_class_data_; }

void AInitWarehouse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AInitWarehouse *>(to)->MergeFrom(
      static_cast<const AInitWarehouse &>(from));
}


void AInitWarehouse::MergeFrom(const AInitWarehouse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AInitWarehouse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AInitWarehouse::CopyFrom(const AInitWarehouse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AInitWarehouse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AInitWarehouse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AInitWarehouse::InternalSwap(AInitWarehouse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AInitWarehouse, y_)
      + sizeof(AInitWarehouse::y_)
      - PROTOBUF_FIELD_OFFSET(AInitWarehouse, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AInitWarehouse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[10]);
}

// ===================================================================

class AConnect::_Internal {
 public:
  using HasBits = decltype(std::declval<AConnect>()._has_bits_);
  static void set_has_worldid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_isamazon(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

AConnect::AConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  initwh_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:AConnect)
}
AConnect::AConnect(const AConnect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      initwh_(from.initwh_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&worldid_, &from.worldid_,
    static_cast<size_t>(reinterpret_cast<char*>(&isamazon_) -
    reinterpret_cast<char*>(&worldid_)) + sizeof(isamazon_));
  // @@protoc_insertion_point(copy_constructor:AConnect)
}

inline void AConnect::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&worldid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isamazon_) -
    reinterpret_cast<char*>(&worldid_)) + sizeof(isamazon_));
}

AConnect::~AConnect() {
  // @@protoc_insertion_point(destructor:AConnect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AConnect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AConnect::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AConnect::Clear() {
// @@protoc_insertion_point(message_clear_start:AConnect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  initwh_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&worldid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&isamazon_) -
        reinterpret_cast<char*>(&worldid_)) + sizeof(isamazon_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AConnect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 worldid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_worldid(&has_bits);
          worldid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .AInitWarehouse initwh = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_initwh(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required bool isAmazon = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_isamazon(&has_bits);
          isamazon_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AConnect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AConnect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 worldid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_worldid(), target);
  }

  // repeated .AInitWarehouse initwh = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_initwh_size()); i < n; i++) {
    const auto& repfield = this->_internal_initwh(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required bool isAmazon = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_isamazon(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AConnect)
  return target;
}

size_t AConnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AConnect)
  size_t total_size = 0;

  // required bool isAmazon = 3;
  if (_internal_has_isamazon()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .AInitWarehouse initwh = 2;
  total_size += 1UL * this->_internal_initwh_size();
  for (const auto& msg : this->initwh_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int64 worldid = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_worldid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AConnect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AConnect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AConnect::GetClassData() const { return &_class_data_; }

void AConnect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AConnect *>(to)->MergeFrom(
      static_cast<const AConnect &>(from));
}


void AConnect::MergeFrom(const AConnect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AConnect)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  initwh_.MergeFrom(from.initwh_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      worldid_ = from.worldid_;
    }
    if (cached_has_bits & 0x00000002u) {
      isamazon_ = from.isamazon_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AConnect::CopyFrom(const AConnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AConnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AConnect::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(initwh_))
    return false;
  return true;
}

void AConnect::InternalSwap(AConnect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  initwh_.InternalSwap(&other->initwh_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AConnect, isamazon_)
      + sizeof(AConnect::isamazon_)
      - PROTOBUF_FIELD_OFFSET(AConnect, worldid_)>(
          reinterpret_cast<char*>(&worldid_),
          reinterpret_cast<char*>(&other->worldid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AConnect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[11]);
}

// ===================================================================

class AConnected::_Internal {
 public:
  using HasBits = decltype(std::declval<AConnected>()._has_bits_);
  static void set_has_worldid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AConnected::AConnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:AConnected)
}
AConnected::AConnected(const AConnected& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  result_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    result_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_result()) {
    result_.Set(from._internal_result(), 
      GetArenaForAllocation());
  }
  worldid_ = from.worldid_;
  // @@protoc_insertion_point(copy_constructor:AConnected)
}

inline void AConnected::SharedCtor() {
result_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  result_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
worldid_ = int64_t{0};
}

AConnected::~AConnected() {
  // @@protoc_insertion_point(destructor:AConnected)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AConnected::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  result_.Destroy();
}

void AConnected::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AConnected::Clear() {
// @@protoc_insertion_point(message_clear_start:AConnected)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    result_.ClearNonDefaultToEmpty();
  }
  worldid_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AConnected::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 worldid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_worldid(&has_bits);
          worldid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_result();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "AConnected.result");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AConnected::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AConnected)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 worldid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_worldid(), target);
  }

  // required string result = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_result().data(), static_cast<int>(this->_internal_result().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "AConnected.result");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AConnected)
  return target;
}

size_t AConnected::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AConnected)
  size_t total_size = 0;

  if (_internal_has_result()) {
    // required string result = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_result());
  }

  if (_internal_has_worldid()) {
    // required int64 worldid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_worldid());
  }

  return total_size;
}
size_t AConnected::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AConnected)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string result = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_result());

    // required int64 worldid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_worldid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AConnected::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AConnected::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AConnected::GetClassData() const { return &_class_data_; }

void AConnected::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AConnected *>(to)->MergeFrom(
      static_cast<const AConnected &>(from));
}


void AConnected::MergeFrom(const AConnected& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AConnected)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_result(from._internal_result());
    }
    if (cached_has_bits & 0x00000002u) {
      worldid_ = from.worldid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AConnected::CopyFrom(const AConnected& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AConnected)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AConnected::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AConnected::InternalSwap(AConnected* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &result_, lhs_arena,
      &other->result_, rhs_arena
  );
  swap(worldid_, other->worldid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AConnected::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[12]);
}

// ===================================================================

class APack::_Internal {
 public:
  using HasBits = decltype(std::declval<APack>()._has_bits_);
  static void set_has_whnum(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_shipid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

APack::APack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  things_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:APack)
}
APack::APack(const APack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      things_(from.things_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&shipid_, &from.shipid_,
    static_cast<size_t>(reinterpret_cast<char*>(&whnum_) -
    reinterpret_cast<char*>(&shipid_)) + sizeof(whnum_));
  // @@protoc_insertion_point(copy_constructor:APack)
}

inline void APack::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&shipid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&whnum_) -
    reinterpret_cast<char*>(&shipid_)) + sizeof(whnum_));
}

APack::~APack() {
  // @@protoc_insertion_point(destructor:APack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void APack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void APack::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void APack::Clear() {
// @@protoc_insertion_point(message_clear_start:APack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  things_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&shipid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&whnum_) -
        reinterpret_cast<char*>(&shipid_)) + sizeof(whnum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* APack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 whnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_whnum(&has_bits);
          whnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .AProduct things = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_things(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required int64 shipid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_shipid(&has_bits);
          shipid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 seqnum = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_seqnum(&has_bits);
          seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* APack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:APack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 whnum = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_whnum(), target);
  }

  // repeated .AProduct things = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_things_size()); i < n; i++) {
    const auto& repfield = this->_internal_things(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required int64 shipid = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_shipid(), target);
  }

  // required int64 seqnum = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_seqnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:APack)
  return target;
}

size_t APack::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:APack)
  size_t total_size = 0;

  if (_internal_has_shipid()) {
    // required int64 shipid = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());
  }

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  if (_internal_has_whnum()) {
    // required int32 whnum = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_whnum());
  }

  return total_size;
}
size_t APack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:APack)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int64 shipid = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());

    // required int64 seqnum = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

    // required int32 whnum = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_whnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .AProduct things = 2;
  total_size += 1UL * this->_internal_things_size();
  for (const auto& msg : this->things_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData APack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    APack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*APack::GetClassData() const { return &_class_data_; }

void APack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<APack *>(to)->MergeFrom(
      static_cast<const APack &>(from));
}


void APack::MergeFrom(const APack& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:APack)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  things_.MergeFrom(from.things_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      shipid_ = from.shipid_;
    }
    if (cached_has_bits & 0x00000002u) {
      seqnum_ = from.seqnum_;
    }
    if (cached_has_bits & 0x00000004u) {
      whnum_ = from.whnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void APack::CopyFrom(const APack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:APack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool APack::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(things_))
    return false;
  return true;
}

void APack::InternalSwap(APack* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  things_.InternalSwap(&other->things_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(APack, whnum_)
      + sizeof(APack::whnum_)
      - PROTOBUF_FIELD_OFFSET(APack, shipid_)>(
          reinterpret_cast<char*>(&shipid_),
          reinterpret_cast<char*>(&other->shipid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata APack::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[13]);
}

// ===================================================================

class APacked::_Internal {
 public:
  using HasBits = decltype(std::declval<APacked>()._has_bits_);
  static void set_has_shipid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

APacked::APacked(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:APacked)
}
APacked::APacked(const APacked& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&shipid_, &from.shipid_,
    static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&shipid_)) + sizeof(seqnum_));
  // @@protoc_insertion_point(copy_constructor:APacked)
}

inline void APacked::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&shipid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&shipid_)) + sizeof(seqnum_));
}

APacked::~APacked() {
  // @@protoc_insertion_point(destructor:APacked)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void APacked::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void APacked::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void APacked::Clear() {
// @@protoc_insertion_point(message_clear_start:APacked)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&shipid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&seqnum_) -
        reinterpret_cast<char*>(&shipid_)) + sizeof(seqnum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* APacked::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 shipid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_shipid(&has_bits);
          shipid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 seqnum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_seqnum(&has_bits);
          seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* APacked::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:APacked)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 shipid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_shipid(), target);
  }

  // required int64 seqnum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_seqnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:APacked)
  return target;
}

size_t APacked::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:APacked)
  size_t total_size = 0;

  if (_internal_has_shipid()) {
    // required int64 shipid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());
  }

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  return total_size;
}
size_t APacked::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:APacked)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 shipid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());

    // required int64 seqnum = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData APacked::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    APacked::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*APacked::GetClassData() const { return &_class_data_; }

void APacked::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<APacked *>(to)->MergeFrom(
      static_cast<const APacked &>(from));
}


void APacked::MergeFrom(const APacked& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:APacked)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      shipid_ = from.shipid_;
    }
    if (cached_has_bits & 0x00000002u) {
      seqnum_ = from.seqnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void APacked::CopyFrom(const APacked& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:APacked)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool APacked::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void APacked::InternalSwap(APacked* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(APacked, seqnum_)
      + sizeof(APacked::seqnum_)
      - PROTOBUF_FIELD_OFFSET(APacked, shipid_)>(
          reinterpret_cast<char*>(&shipid_),
          reinterpret_cast<char*>(&other->shipid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata APacked::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[14]);
}

// ===================================================================

class ALoaded::_Internal {
 public:
  using HasBits = decltype(std::declval<ALoaded>()._has_bits_);
  static void set_has_shipid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

ALoaded::ALoaded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ALoaded)
}
ALoaded::ALoaded(const ALoaded& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&shipid_, &from.shipid_,
    static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&shipid_)) + sizeof(seqnum_));
  // @@protoc_insertion_point(copy_constructor:ALoaded)
}

inline void ALoaded::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&shipid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&shipid_)) + sizeof(seqnum_));
}

ALoaded::~ALoaded() {
  // @@protoc_insertion_point(destructor:ALoaded)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ALoaded::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ALoaded::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ALoaded::Clear() {
// @@protoc_insertion_point(message_clear_start:ALoaded)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&shipid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&seqnum_) -
        reinterpret_cast<char*>(&shipid_)) + sizeof(seqnum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ALoaded::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 shipid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_shipid(&has_bits);
          shipid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 seqnum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_seqnum(&has_bits);
          seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ALoaded::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ALoaded)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 shipid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_shipid(), target);
  }

  // required int64 seqnum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_seqnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ALoaded)
  return target;
}

size_t ALoaded::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ALoaded)
  size_t total_size = 0;

  if (_internal_has_shipid()) {
    // required int64 shipid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());
  }

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  return total_size;
}
size_t ALoaded::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ALoaded)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 shipid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());

    // required int64 seqnum = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ALoaded::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ALoaded::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ALoaded::GetClassData() const { return &_class_data_; }

void ALoaded::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ALoaded *>(to)->MergeFrom(
      static_cast<const ALoaded &>(from));
}


void ALoaded::MergeFrom(const ALoaded& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ALoaded)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      shipid_ = from.shipid_;
    }
    if (cached_has_bits & 0x00000002u) {
      seqnum_ = from.seqnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ALoaded::CopyFrom(const ALoaded& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ALoaded)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ALoaded::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ALoaded::InternalSwap(ALoaded* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ALoaded, seqnum_)
      + sizeof(ALoaded::seqnum_)
      - PROTOBUF_FIELD_OFFSET(ALoaded, shipid_)>(
          reinterpret_cast<char*>(&shipid_),
          reinterpret_cast<char*>(&other->shipid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ALoaded::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[15]);
}

// ===================================================================

class APutOnTruck::_Internal {
 public:
  using HasBits = decltype(std::declval<APutOnTruck>()._has_bits_);
  static void set_has_whnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_truckid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_shipid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

APutOnTruck::APutOnTruck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:APutOnTruck)
}
APutOnTruck::APutOnTruck(const APutOnTruck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&whnum_, &from.whnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&whnum_)) + sizeof(seqnum_));
  // @@protoc_insertion_point(copy_constructor:APutOnTruck)
}

inline void APutOnTruck::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&whnum_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&whnum_)) + sizeof(seqnum_));
}

APutOnTruck::~APutOnTruck() {
  // @@protoc_insertion_point(destructor:APutOnTruck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void APutOnTruck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void APutOnTruck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void APutOnTruck::Clear() {
// @@protoc_insertion_point(message_clear_start:APutOnTruck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&whnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&seqnum_) -
        reinterpret_cast<char*>(&whnum_)) + sizeof(seqnum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* APutOnTruck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 whnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_whnum(&has_bits);
          whnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 truckid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_truckid(&has_bits);
          truckid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 shipid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_shipid(&has_bits);
          shipid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 seqnum = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_seqnum(&has_bits);
          seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* APutOnTruck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:APutOnTruck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 whnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_whnum(), target);
  }

  // required int32 truckid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_truckid(), target);
  }

  // required int64 shipid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_shipid(), target);
  }

  // required int64 seqnum = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_seqnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:APutOnTruck)
  return target;
}

size_t APutOnTruck::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:APutOnTruck)
  size_t total_size = 0;

  if (_internal_has_whnum()) {
    // required int32 whnum = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_whnum());
  }

  if (_internal_has_truckid()) {
    // required int32 truckid = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_truckid());
  }

  if (_internal_has_shipid()) {
    // required int64 shipid = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());
  }

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  return total_size;
}
size_t APutOnTruck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:APutOnTruck)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 whnum = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_whnum());

    // required int32 truckid = 2;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_truckid());

    // required int64 shipid = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shipid());

    // required int64 seqnum = 4;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData APutOnTruck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    APutOnTruck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*APutOnTruck::GetClassData() const { return &_class_data_; }

void APutOnTruck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<APutOnTruck *>(to)->MergeFrom(
      static_cast<const APutOnTruck &>(from));
}


void APutOnTruck::MergeFrom(const APutOnTruck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:APutOnTruck)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      whnum_ = from.whnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      truckid_ = from.truckid_;
    }
    if (cached_has_bits & 0x00000004u) {
      shipid_ = from.shipid_;
    }
    if (cached_has_bits & 0x00000008u) {
      seqnum_ = from.seqnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void APutOnTruck::CopyFrom(const APutOnTruck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:APutOnTruck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool APutOnTruck::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void APutOnTruck::InternalSwap(APutOnTruck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(APutOnTruck, seqnum_)
      + sizeof(APutOnTruck::seqnum_)
      - PROTOBUF_FIELD_OFFSET(APutOnTruck, whnum_)>(
          reinterpret_cast<char*>(&whnum_),
          reinterpret_cast<char*>(&other->whnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata APutOnTruck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[16]);
}

// ===================================================================

class APurchaseMore::_Internal {
 public:
  using HasBits = decltype(std::declval<APurchaseMore>()._has_bits_);
  static void set_has_whnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

APurchaseMore::APurchaseMore(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  things_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:APurchaseMore)
}
APurchaseMore::APurchaseMore(const APurchaseMore& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      things_(from.things_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&seqnum_, &from.seqnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&whnum_) -
    reinterpret_cast<char*>(&seqnum_)) + sizeof(whnum_));
  // @@protoc_insertion_point(copy_constructor:APurchaseMore)
}

inline void APurchaseMore::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seqnum_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&whnum_) -
    reinterpret_cast<char*>(&seqnum_)) + sizeof(whnum_));
}

APurchaseMore::~APurchaseMore() {
  // @@protoc_insertion_point(destructor:APurchaseMore)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void APurchaseMore::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void APurchaseMore::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void APurchaseMore::Clear() {
// @@protoc_insertion_point(message_clear_start:APurchaseMore)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  things_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&seqnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&whnum_) -
        reinterpret_cast<char*>(&seqnum_)) + sizeof(whnum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* APurchaseMore::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 whnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_whnum(&has_bits);
          whnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .AProduct things = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_things(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required int64 seqnum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_seqnum(&has_bits);
          seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* APurchaseMore::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:APurchaseMore)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 whnum = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_whnum(), target);
  }

  // repeated .AProduct things = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_things_size()); i < n; i++) {
    const auto& repfield = this->_internal_things(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required int64 seqnum = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_seqnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:APurchaseMore)
  return target;
}

size_t APurchaseMore::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:APurchaseMore)
  size_t total_size = 0;

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  if (_internal_has_whnum()) {
    // required int32 whnum = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_whnum());
  }

  return total_size;
}
size_t APurchaseMore::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:APurchaseMore)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 seqnum = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

    // required int32 whnum = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_whnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .AProduct things = 2;
  total_size += 1UL * this->_internal_things_size();
  for (const auto& msg : this->things_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData APurchaseMore::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    APurchaseMore::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*APurchaseMore::GetClassData() const { return &_class_data_; }

void APurchaseMore::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<APurchaseMore *>(to)->MergeFrom(
      static_cast<const APurchaseMore &>(from));
}


void APurchaseMore::MergeFrom(const APurchaseMore& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:APurchaseMore)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  things_.MergeFrom(from.things_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      seqnum_ = from.seqnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      whnum_ = from.whnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void APurchaseMore::CopyFrom(const APurchaseMore& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:APurchaseMore)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool APurchaseMore::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(things_))
    return false;
  return true;
}

void APurchaseMore::InternalSwap(APurchaseMore* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  things_.InternalSwap(&other->things_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(APurchaseMore, whnum_)
      + sizeof(APurchaseMore::whnum_)
      - PROTOBUF_FIELD_OFFSET(APurchaseMore, seqnum_)>(
          reinterpret_cast<char*>(&seqnum_),
          reinterpret_cast<char*>(&other->seqnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata APurchaseMore::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[17]);
}

// ===================================================================

class AErr::_Internal {
 public:
  using HasBits = decltype(std::declval<AErr>()._has_bits_);
  static void set_has_err(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_originseqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

AErr::AErr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:AErr)
}
AErr::AErr(const AErr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  err_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    err_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_err()) {
    err_.Set(from._internal_err(), 
      GetArenaForAllocation());
  }
  ::memcpy(&originseqnum_, &from.originseqnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&originseqnum_)) + sizeof(seqnum_));
  // @@protoc_insertion_point(copy_constructor:AErr)
}

inline void AErr::SharedCtor() {
err_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  err_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&originseqnum_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&originseqnum_)) + sizeof(seqnum_));
}

AErr::~AErr() {
  // @@protoc_insertion_point(destructor:AErr)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AErr::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  err_.Destroy();
}

void AErr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AErr::Clear() {
// @@protoc_insertion_point(message_clear_start:AErr)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    err_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&originseqnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&seqnum_) -
        reinterpret_cast<char*>(&originseqnum_)) + sizeof(seqnum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AErr::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string err = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_err();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "AErr.err");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 originseqnum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_originseqnum(&has_bits);
          originseqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 seqnum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_seqnum(&has_bits);
          seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AErr::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AErr)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string err = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_err().data(), static_cast<int>(this->_internal_err().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "AErr.err");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_err(), target);
  }

  // required int64 originseqnum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_originseqnum(), target);
  }

  // required int64 seqnum = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_seqnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AErr)
  return target;
}

size_t AErr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AErr)
  size_t total_size = 0;

  if (_internal_has_err()) {
    // required string err = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_err());
  }

  if (_internal_has_originseqnum()) {
    // required int64 originseqnum = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_originseqnum());
  }

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  return total_size;
}
size_t AErr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AErr)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string err = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_err());

    // required int64 originseqnum = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_originseqnum());

    // required int64 seqnum = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AErr::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AErr::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AErr::GetClassData() const { return &_class_data_; }

void AErr::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AErr *>(to)->MergeFrom(
      static_cast<const AErr &>(from));
}


void AErr::MergeFrom(const AErr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AErr)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_err(from._internal_err());
    }
    if (cached_has_bits & 0x00000002u) {
      originseqnum_ = from.originseqnum_;
    }
    if (cached_has_bits & 0x00000004u) {
      seqnum_ = from.seqnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AErr::CopyFrom(const AErr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AErr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AErr::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AErr::InternalSwap(AErr* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &err_, lhs_arena,
      &other->err_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AErr, seqnum_)
      + sizeof(AErr::seqnum_)
      - PROTOBUF_FIELD_OFFSET(AErr, originseqnum_)>(
          reinterpret_cast<char*>(&originseqnum_),
          reinterpret_cast<char*>(&other->originseqnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AErr::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[18]);
}

// ===================================================================

class AQuery::_Internal {
 public:
  using HasBits = decltype(std::declval<AQuery>()._has_bits_);
  static void set_has_packageid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

AQuery::AQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:AQuery)
}
AQuery::AQuery(const AQuery& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&packageid_, &from.packageid_,
    static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&packageid_)) + sizeof(seqnum_));
  // @@protoc_insertion_point(copy_constructor:AQuery)
}

inline void AQuery::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&packageid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&packageid_)) + sizeof(seqnum_));
}

AQuery::~AQuery() {
  // @@protoc_insertion_point(destructor:AQuery)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AQuery::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AQuery::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AQuery::Clear() {
// @@protoc_insertion_point(message_clear_start:AQuery)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&packageid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&seqnum_) -
        reinterpret_cast<char*>(&packageid_)) + sizeof(seqnum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AQuery::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 packageid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_packageid(&has_bits);
          packageid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 seqnum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_seqnum(&has_bits);
          seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AQuery::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AQuery)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 packageid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_packageid(), target);
  }

  // required int64 seqnum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_seqnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AQuery)
  return target;
}

size_t AQuery::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:AQuery)
  size_t total_size = 0;

  if (_internal_has_packageid()) {
    // required int64 packageid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_packageid());
  }

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  return total_size;
}
size_t AQuery::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AQuery)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 packageid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_packageid());

    // required int64 seqnum = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AQuery::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AQuery::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AQuery::GetClassData() const { return &_class_data_; }

void AQuery::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AQuery *>(to)->MergeFrom(
      static_cast<const AQuery &>(from));
}


void AQuery::MergeFrom(const AQuery& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AQuery)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      packageid_ = from.packageid_;
    }
    if (cached_has_bits & 0x00000002u) {
      seqnum_ = from.seqnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AQuery::CopyFrom(const AQuery& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AQuery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AQuery::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void AQuery::InternalSwap(AQuery* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AQuery, seqnum_)
      + sizeof(AQuery::seqnum_)
      - PROTOBUF_FIELD_OFFSET(AQuery, packageid_)>(
          reinterpret_cast<char*>(&packageid_),
          reinterpret_cast<char*>(&other->packageid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AQuery::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[19]);
}

// ===================================================================

class APackage::_Internal {
 public:
  using HasBits = decltype(std::declval<APackage>()._has_bits_);
  static void set_has_packageid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seqnum(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

APackage::APackage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:APackage)
}
APackage::APackage(const APackage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    status_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_status()) {
    status_.Set(from._internal_status(), 
      GetArenaForAllocation());
  }
  ::memcpy(&packageid_, &from.packageid_,
    static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&packageid_)) + sizeof(seqnum_));
  // @@protoc_insertion_point(copy_constructor:APackage)
}

inline void APackage::SharedCtor() {
status_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  status_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&packageid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seqnum_) -
    reinterpret_cast<char*>(&packageid_)) + sizeof(seqnum_));
}

APackage::~APackage() {
  // @@protoc_insertion_point(destructor:APackage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void APackage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  status_.Destroy();
}

void APackage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void APackage::Clear() {
// @@protoc_insertion_point(message_clear_start:APackage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    status_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&packageid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&seqnum_) -
        reinterpret_cast<char*>(&packageid_)) + sizeof(seqnum_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* APackage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 packageid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_packageid(&has_bits);
          packageid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_status();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "APackage.status");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // required int64 seqnum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_seqnum(&has_bits);
          seqnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* APackage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:APackage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 packageid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_packageid(), target);
  }

  // required string status = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "APackage.status");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_status(), target);
  }

  // required int64 seqnum = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_seqnum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:APackage)
  return target;
}

size_t APackage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:APackage)
  size_t total_size = 0;

  if (_internal_has_status()) {
    // required string status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());
  }

  if (_internal_has_packageid()) {
    // required int64 packageid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_packageid());
  }

  if (_internal_has_seqnum()) {
    // required int64 seqnum = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());
  }

  return total_size;
}
size_t APackage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:APackage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status());

    // required int64 packageid = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_packageid());

    // required int64 seqnum = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seqnum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData APackage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    APackage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*APackage::GetClassData() const { return &_class_data_; }

void APackage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<APackage *>(to)->MergeFrom(
      static_cast<const APackage &>(from));
}


void APackage::MergeFrom(const APackage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:APackage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000002u) {
      packageid_ = from.packageid_;
    }
    if (cached_has_bits & 0x00000004u) {
      seqnum_ = from.seqnum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void APackage::CopyFrom(const APackage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:APackage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool APackage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void APackage::InternalSwap(APackage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &status_, lhs_arena,
      &other->status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(APackage, seqnum_)
      + sizeof(APackage::seqnum_)
      - PROTOBUF_FIELD_OFFSET(APackage, packageid_)>(
          reinterpret_cast<char*>(&packageid_),
          reinterpret_cast<char*>(&other->packageid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata APackage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[20]);
}

// ===================================================================

class ACommands::_Internal {
 public:
  using HasBits = decltype(std::declval<ACommands>()._has_bits_);
  static void set_has_simspeed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_disconnect(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ACommands::ACommands(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  buy_(arena),
  topack_(arena),
  load_(arena),
  queries_(arena),
  acks_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:ACommands)
}
ACommands::ACommands(const ACommands& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      buy_(from.buy_),
      topack_(from.topack_),
      load_(from.load_),
      queries_(from.queries_),
      acks_(from.acks_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&simspeed_, &from.simspeed_,
    static_cast<size_t>(reinterpret_cast<char*>(&disconnect_) -
    reinterpret_cast<char*>(&simspeed_)) + sizeof(disconnect_));
  // @@protoc_insertion_point(copy_constructor:ACommands)
}

inline void ACommands::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&simspeed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&disconnect_) -
    reinterpret_cast<char*>(&simspeed_)) + sizeof(disconnect_));
}

ACommands::~ACommands() {
  // @@protoc_insertion_point(destructor:ACommands)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ACommands::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ACommands::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ACommands::Clear() {
// @@protoc_insertion_point(message_clear_start:ACommands)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  buy_.Clear();
  topack_.Clear();
  load_.Clear();
  queries_.Clear();
  acks_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&simspeed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&disconnect_) -
        reinterpret_cast<char*>(&simspeed_)) + sizeof(disconnect_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ACommands::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .APurchaseMore buy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_buy(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .APack topack = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_topack(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .APutOnTruck load = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_load(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .AQuery queries = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_queries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 simspeed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_simspeed(&has_bits);
          simspeed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disconnect = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_disconnect(&has_bits);
          disconnect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 acks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_acks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_acks(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ACommands::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ACommands)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .APurchaseMore buy = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_buy_size()); i < n; i++) {
    const auto& repfield = this->_internal_buy(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .APack topack = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_topack_size()); i < n; i++) {
    const auto& repfield = this->_internal_topack(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .APutOnTruck load = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_load_size()); i < n; i++) {
    const auto& repfield = this->_internal_load(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .AQuery queries = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_queries_size()); i < n; i++) {
    const auto& repfield = this->_internal_queries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 simspeed = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_simspeed(), target);
  }

  // optional bool disconnect = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_disconnect(), target);
  }

  // repeated int64 acks = 7;
  for (int i = 0, n = this->_internal_acks_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_acks(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ACommands)
  return target;
}

size_t ACommands::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ACommands)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .APurchaseMore buy = 1;
  total_size += 1UL * this->_internal_buy_size();
  for (const auto& msg : this->buy_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .APack topack = 2;
  total_size += 1UL * this->_internal_topack_size();
  for (const auto& msg : this->topack_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .APutOnTruck load = 3;
  total_size += 1UL * this->_internal_load_size();
  for (const auto& msg : this->load_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .AQuery queries = 4;
  total_size += 1UL * this->_internal_queries_size();
  for (const auto& msg : this->queries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int64 acks = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->acks_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_acks_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 simspeed = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_simspeed());
    }

    // optional bool disconnect = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ACommands::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ACommands::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ACommands::GetClassData() const { return &_class_data_; }

void ACommands::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ACommands *>(to)->MergeFrom(
      static_cast<const ACommands &>(from));
}


void ACommands::MergeFrom(const ACommands& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ACommands)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  buy_.MergeFrom(from.buy_);
  topack_.MergeFrom(from.topack_);
  load_.MergeFrom(from.load_);
  queries_.MergeFrom(from.queries_);
  acks_.MergeFrom(from.acks_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      simspeed_ = from.simspeed_;
    }
    if (cached_has_bits & 0x00000002u) {
      disconnect_ = from.disconnect_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ACommands::CopyFrom(const ACommands& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ACommands)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACommands::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(buy_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(topack_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(load_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(queries_))
    return false;
  return true;
}

void ACommands::InternalSwap(ACommands* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  buy_.InternalSwap(&other->buy_);
  topack_.InternalSwap(&other->topack_);
  load_.InternalSwap(&other->load_);
  queries_.InternalSwap(&other->queries_);
  acks_.InternalSwap(&other->acks_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ACommands, disconnect_)
      + sizeof(ACommands::disconnect_)
      - PROTOBUF_FIELD_OFFSET(ACommands, simspeed_)>(
          reinterpret_cast<char*>(&simspeed_),
          reinterpret_cast<char*>(&other->simspeed_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ACommands::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[21]);
}

// ===================================================================

class AResponses::_Internal {
 public:
  using HasBits = decltype(std::declval<AResponses>()._has_bits_);
  static void set_has_finished(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AResponses::AResponses(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  arrived_(arena),
  ready_(arena),
  loaded_(arena),
  error_(arena),
  acks_(arena),
  packagestatus_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:AResponses)
}
AResponses::AResponses(const AResponses& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      arrived_(from.arrived_),
      ready_(from.ready_),
      loaded_(from.loaded_),
      error_(from.error_),
      acks_(from.acks_),
      packagestatus_(from.packagestatus_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  finished_ = from.finished_;
  // @@protoc_insertion_point(copy_constructor:AResponses)
}

inline void AResponses::SharedCtor() {
finished_ = false;
}

AResponses::~AResponses() {
  // @@protoc_insertion_point(destructor:AResponses)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AResponses::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AResponses::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AResponses::Clear() {
// @@protoc_insertion_point(message_clear_start:AResponses)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  arrived_.Clear();
  ready_.Clear();
  loaded_.Clear();
  error_.Clear();
  acks_.Clear();
  packagestatus_.Clear();
  finished_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AResponses::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .APurchaseMore arrived = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_arrived(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .APacked ready = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ready(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ALoaded loaded = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_loaded(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool finished = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_finished(&has_bits);
          finished_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .AErr error = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_error(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 acks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_acks(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_acks(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .APackage packagestatus = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_packagestatus(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AResponses::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AResponses)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .APurchaseMore arrived = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_arrived_size()); i < n; i++) {
    const auto& repfield = this->_internal_arrived(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .APacked ready = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ready_size()); i < n; i++) {
    const auto& repfield = this->_internal_ready(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .ALoaded loaded = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_loaded_size()); i < n; i++) {
    const auto& repfield = this->_internal_loaded(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool finished = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_finished(), target);
  }

  // repeated .AErr error = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_error_size()); i < n; i++) {
    const auto& repfield = this->_internal_error(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated int64 acks = 6;
  for (int i = 0, n = this->_internal_acks_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_acks(i), target);
  }

  // repeated .APackage packagestatus = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_packagestatus_size()); i < n; i++) {
    const auto& repfield = this->_internal_packagestatus(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AResponses)
  return target;
}

size_t AResponses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AResponses)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .APurchaseMore arrived = 1;
  total_size += 1UL * this->_internal_arrived_size();
  for (const auto& msg : this->arrived_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .APacked ready = 2;
  total_size += 1UL * this->_internal_ready_size();
  for (const auto& msg : this->ready_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .ALoaded loaded = 3;
  total_size += 1UL * this->_internal_loaded_size();
  for (const auto& msg : this->loaded_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .AErr error = 5;
  total_size += 1UL * this->_internal_error_size();
  for (const auto& msg : this->error_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int64 acks = 6;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->acks_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_acks_size());
    total_size += data_size;
  }

  // repeated .APackage packagestatus = 7;
  total_size += 1UL * this->_internal_packagestatus_size();
  for (const auto& msg : this->packagestatus_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool finished = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AResponses::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AResponses::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AResponses::GetClassData() const { return &_class_data_; }

void AResponses::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AResponses *>(to)->MergeFrom(
      static_cast<const AResponses &>(from));
}


void AResponses::MergeFrom(const AResponses& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AResponses)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  arrived_.MergeFrom(from.arrived_);
  ready_.MergeFrom(from.ready_);
  loaded_.MergeFrom(from.loaded_);
  error_.MergeFrom(from.error_);
  acks_.MergeFrom(from.acks_);
  packagestatus_.MergeFrom(from.packagestatus_);
  if (from._internal_has_finished()) {
    _internal_set_finished(from._internal_finished());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AResponses::CopyFrom(const AResponses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AResponses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AResponses::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(arrived_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(ready_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(loaded_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(error_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(packagestatus_))
    return false;
  return true;
}

void AResponses::InternalSwap(AResponses* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  arrived_.InternalSwap(&other->arrived_);
  ready_.InternalSwap(&other->ready_);
  loaded_.InternalSwap(&other->loaded_);
  error_.InternalSwap(&other->error_);
  acks_.InternalSwap(&other->acks_);
  packagestatus_.InternalSwap(&other->packagestatus_);
  swap(finished_, other->finished_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AResponses::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_world_5famazon_2eproto_getter, &descriptor_table_world_5famazon_2eproto_once,
      file_level_metadata_world_5famazon_2eproto[22]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::UtoAzConnect*
Arena::CreateMaybeMessage< ::UtoAzConnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UtoAzConnect >(arena);
}
template<> PROTOBUF_NOINLINE ::AzConnected*
Arena::CreateMaybeMessage< ::AzConnected >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AzConnected >(arena);
}
template<> PROTOBUF_NOINLINE ::AItem*
Arena::CreateMaybeMessage< ::AItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AItem >(arena);
}
template<> PROTOBUF_NOINLINE ::ASendTruck*
Arena::CreateMaybeMessage< ::ASendTruck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ASendTruck >(arena);
}
template<> PROTOBUF_NOINLINE ::UTruckAtWH*
Arena::CreateMaybeMessage< ::UTruckAtWH >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UTruckAtWH >(arena);
}
template<> PROTOBUF_NOINLINE ::ATruckLoaded*
Arena::CreateMaybeMessage< ::ATruckLoaded >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ATruckLoaded >(arena);
}
template<> PROTOBUF_NOINLINE ::UPackageDelivered*
Arena::CreateMaybeMessage< ::UPackageDelivered >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UPackageDelivered >(arena);
}
template<> PROTOBUF_NOINLINE ::UMessage*
Arena::CreateMaybeMessage< ::UMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AMessage*
Arena::CreateMaybeMessage< ::AMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::AProduct*
Arena::CreateMaybeMessage< ::AProduct >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AProduct >(arena);
}
template<> PROTOBUF_NOINLINE ::AInitWarehouse*
Arena::CreateMaybeMessage< ::AInitWarehouse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AInitWarehouse >(arena);
}
template<> PROTOBUF_NOINLINE ::AConnect*
Arena::CreateMaybeMessage< ::AConnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AConnect >(arena);
}
template<> PROTOBUF_NOINLINE ::AConnected*
Arena::CreateMaybeMessage< ::AConnected >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AConnected >(arena);
}
template<> PROTOBUF_NOINLINE ::APack*
Arena::CreateMaybeMessage< ::APack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::APack >(arena);
}
template<> PROTOBUF_NOINLINE ::APacked*
Arena::CreateMaybeMessage< ::APacked >(Arena* arena) {
  return Arena::CreateMessageInternal< ::APacked >(arena);
}
template<> PROTOBUF_NOINLINE ::ALoaded*
Arena::CreateMaybeMessage< ::ALoaded >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ALoaded >(arena);
}
template<> PROTOBUF_NOINLINE ::APutOnTruck*
Arena::CreateMaybeMessage< ::APutOnTruck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::APutOnTruck >(arena);
}
template<> PROTOBUF_NOINLINE ::APurchaseMore*
Arena::CreateMaybeMessage< ::APurchaseMore >(Arena* arena) {
  return Arena::CreateMessageInternal< ::APurchaseMore >(arena);
}
template<> PROTOBUF_NOINLINE ::AErr*
Arena::CreateMaybeMessage< ::AErr >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AErr >(arena);
}
template<> PROTOBUF_NOINLINE ::AQuery*
Arena::CreateMaybeMessage< ::AQuery >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AQuery >(arena);
}
template<> PROTOBUF_NOINLINE ::APackage*
Arena::CreateMaybeMessage< ::APackage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::APackage >(arena);
}
template<> PROTOBUF_NOINLINE ::ACommands*
Arena::CreateMaybeMessage< ::ACommands >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ACommands >(arena);
}
template<> PROTOBUF_NOINLINE ::AResponses*
Arena::CreateMaybeMessage< ::AResponses >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AResponses >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
